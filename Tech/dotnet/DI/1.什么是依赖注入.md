## 什么是依赖注入

依赖注入（Dependency Injection，简称 DI）是 C# 和 .NET 中实现**控制反转（IoC）** 的一种设计模式，用于管理类之间的依赖关系，提高代码的可测试性、可维护性和松耦合性。

------

### 核心概念

1. **依赖**：一个类需要另一个类才能正常工作。

   ```c#
   public class OrderService
   {
       private readonly IEmailService _emailService; // 依赖
       public OrderService(IEmailService emailService)
       {
           _emailService = emailService;
       }
   }
   ```

2. **注入**：通过外部（例如容器）提供依赖的实例，而非在类内部直接创建。

   ```csharp
   // 传统方式（紧耦合）
   public class OrderService
   {
       private IEmailService _emailService = new EmailService(); // 内部创建依赖
   }
   
   // 依赖注入方式（解耦）
   public class OrderService
   {
       private readonly IEmailService _emailService;
       public OrderService(IEmailService emailService) // 依赖通过构造函数"注入"
       {
           _emailService = emailService;
       }
   }
   ```

------

### 依赖注入的三种方式

1. **构造函数注入**（最常用）

   通过构造函数传递依赖。

   ```c#
   public class OrderService
   {
       private readonly IEmailService _emailService;
       public OrderService(IEmailService emailService)
       {
           _emailService = emailService;
       }
   }
   ```

2. **方法注入**

   通过方法参数传递依赖。

   ```c#
   public class OrderService
   {
       public void ProcessOrder(IEmailService emailService)
       {
           emailService.SendEmail("订单已处理");
       }
   }
   ```

3. **属性注入**

   通过公共属性设置依赖。

   ```c#
   public class OrderService
   {
       public IEmailService EmailService { get; set; }
   }
   ```

------

### 依赖注入容器

在 .NET 中，常用内置的 `IServiceCollection`容器管理依赖关系：

```c#
// 注册服务
public void ConfigureServices(IServiceCollection services)
{
    services.AddTransient<IEmailService, SmtpEmailService>(); // 瞬时生命周期
    services.AddScoped<IOrderService, OrderService>();         // 作用域生命周期
    services.AddSingleton<ILogger, FileLogger>();              // 单例生命周期
}

// 使用服务
public class HomeController : Controller
{
    private readonly IEmailService _emailService;
    public HomeController(IEmailService emailService) // 容器自动注入
    {
        _emailService = emailService;
    }
}
```

------

### 生命周期类型

1. **Transient**：每次请求都创建新实例。
2. **Scoped**：在同一作用域（如一次 Web 请求）内使用同一实例。
3. **Singleton**：整个应用程序生命周期内使用同一实例。

------

### 优势

- **解耦**：类不直接依赖具体实现，而是依赖抽象（接口）。
- **可测试性**：可通过 Mock 依赖进行单元测试。
- **可维护性**：更换依赖实现时无需修改原有代码。

------

### 示例：完整的 DI 流程

```c#
// 1. 定义接口
public interface IMessageService
{
    void Send(string message);
}

// 2. 实现接口
public class SmsService : IMessageService
{
    public void Send(string message) => Console.WriteLine($"短信发送：{message}");
}

// 3. 注册服务（在 Program.cs 或 Startup.cs）
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddTransient<IMessageService, SmsService>();

// 4. 通过构造函数注入使用
public class Notification
{
    private readonly IMessageService _messageService;
    public Notification(IMessageService messageService)
    {
        _messageService = messageService;
    }
    
    public void Notify(string message) => _messageService.Send(message);
}
```

------

### 总结

依赖注入是现代 .NET 开发的核心模式，通过将依赖关系的控制权从类内部转移到外部容器，显著提升了代码的灵活性和可测试性。在 ASP.NET Core、WPF、Xamarin 等框架中广泛使用。

